// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `parse_peer_id`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`, `from`, `from`, `from`

Future<void> startFungiDaemon() =>
    RustLib.instance.api.crateApiFungiStartFungiDaemon();

String? hostName() => RustLib.instance.api.crateApiFungiHostName();

String peerId() => RustLib.instance.api.crateApiFungiPeerId();

String configFilePath() => RustLib.instance.api.crateApiFungiConfigFilePath();

List<String> getIncomingAllowedPeersList() =>
    RustLib.instance.api.crateApiFungiGetIncomingAllowedPeersList();

void addIncomingAllowedPeer({required String peerId}) =>
    RustLib.instance.api.crateApiFungiAddIncomingAllowedPeer(peerId: peerId);

void removeIncomingAllowedPeer({required String peerId}) =>
    RustLib.instance.api.crateApiFungiRemoveIncomingAllowedPeer(peerId: peerId);

bool getFileTransferServiceEnabled() =>
    RustLib.instance.api.crateApiFungiGetFileTransferServiceEnabled();

String getFileTransferServiceRootDir() =>
    RustLib.instance.api.crateApiFungiGetFileTransferServiceRootDir();

Future<void> startFileTransferService({required String rootDir}) => RustLib
    .instance
    .api
    .crateApiFungiStartFileTransferService(rootDir: rootDir);

void stopFileTransferService() =>
    RustLib.instance.api.crateApiFungiStopFileTransferService();

Future<void> addFileTransferClient({
  required bool enabled,
  String? name,
  required String peerId,
}) => RustLib.instance.api.crateApiFungiAddFileTransferClient(
  enabled: enabled,
  name: name,
  peerId: peerId,
);

void removeFileTransferClient({required String peerId}) =>
    RustLib.instance.api.crateApiFungiRemoveFileTransferClient(peerId: peerId);

Future<void> enableFileTransferClient({
  required String peerId,
  required bool enabled,
}) => RustLib.instance.api.crateApiFungiEnableFileTransferClient(
  peerId: peerId,
  enabled: enabled,
);

List<FileTransferClient> getAllFileTransferClients() =>
    RustLib.instance.api.crateApiFungiGetAllFileTransferClients();

FtpProxy getFtpProxy() => RustLib.instance.api.crateApiFungiGetFtpProxy();

void updateFtpProxy({
  required bool enabled,
  required String host,
  required int port,
}) => RustLib.instance.api.crateApiFungiUpdateFtpProxy(
  enabled: enabled,
  host: host,
  port: port,
);

WebdavProxy getWebdavProxy() =>
    RustLib.instance.api.crateApiFungiGetWebdavProxy();

void updateWebdavProxy({
  required bool enabled,
  required String host,
  required int port,
}) => RustLib.instance.api.crateApiFungiUpdateWebdavProxy(
  enabled: enabled,
  host: host,
  port: port,
);

TcpTunnelingConfig getTcpTunnelingConfig() =>
    RustLib.instance.api.crateApiFungiGetTcpTunnelingConfig();

Future<String> addTcpForwardingRule({
  required String localHost,
  required int localPort,
  required String peerId,
  required int remotePort,
}) => RustLib.instance.api.crateApiFungiAddTcpForwardingRule(
  localHost: localHost,
  localPort: localPort,
  peerId: peerId,
  remotePort: remotePort,
);

void removeTcpForwardingRule({required String ruleId}) =>
    RustLib.instance.api.crateApiFungiRemoveTcpForwardingRule(ruleId: ruleId);

Future<String> addTcpListeningRule({
  required String localHost,
  required int localPort,
  required List<String> allowedPeers,
}) => RustLib.instance.api.crateApiFungiAddTcpListeningRule(
  localHost: localHost,
  localPort: localPort,
  allowedPeers: allowedPeers,
);

void removeTcpListeningRule({required String ruleId}) =>
    RustLib.instance.api.crateApiFungiRemoveTcpListeningRule(ruleId: ruleId);

Future<List<PeerInfo>> getLocalDevices() =>
    RustLib.instance.api.crateApiFungiGetLocalDevices();

List<PeerInfo> getAllKnownPeers() =>
    RustLib.instance.api.crateApiFungiGetAllKnownPeers();

void addOrUpdateKnownPeer({required String peerId, String? hostname}) => RustLib
    .instance
    .api
    .crateApiFungiAddOrUpdateKnownPeer(peerId: peerId, hostname: hostname);

PeerInfo? getKnownPeerInfo({required String peerId}) =>
    RustLib.instance.api.crateApiFungiGetKnownPeerInfo(peerId: peerId);

void removeKnownPeer({required String peerId}) =>
    RustLib.instance.api.crateApiFungiRemoveKnownPeer(peerId: peerId);

List<PeerWithInfo> getIncomingAllowedPeersWithInfo() =>
    RustLib.instance.api.crateApiFungiGetIncomingAllowedPeersWithInfo();

class FileTransferClient {
  final bool enabled;
  final String? name;
  final String peerId;

  const FileTransferClient({
    required this.enabled,
    this.name,
    required this.peerId,
  });

  @override
  int get hashCode => enabled.hashCode ^ name.hashCode ^ peerId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileTransferClient &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          name == other.name &&
          peerId == other.peerId;
}

class ForwardingRule {
  final String localHost;
  final int localPort;
  final String remotePeerId;
  final int remotePort;

  const ForwardingRule({
    required this.localHost,
    required this.localPort,
    required this.remotePeerId,
    required this.remotePort,
  });

  @override
  int get hashCode =>
      localHost.hashCode ^
      localPort.hashCode ^
      remotePeerId.hashCode ^
      remotePort.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ForwardingRule &&
          runtimeType == other.runtimeType &&
          localHost == other.localHost &&
          localPort == other.localPort &&
          remotePeerId == other.remotePeerId &&
          remotePort == other.remotePort;
}

class FtpProxy {
  final bool enabled;
  final String host;
  final int port;

  const FtpProxy({
    required this.enabled,
    required this.host,
    required this.port,
  });

  @override
  int get hashCode => enabled.hashCode ^ host.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FtpProxy &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          host == other.host &&
          port == other.port;
}

class ListeningRule {
  final String host;
  final int port;
  final List<String> allowedPeers;

  const ListeningRule({
    required this.host,
    required this.port,
    required this.allowedPeers,
  });

  @override
  int get hashCode => host.hashCode ^ port.hashCode ^ allowedPeers.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is ListeningRule &&
          runtimeType == other.runtimeType &&
          host == other.host &&
          port == other.port &&
          allowedPeers == other.allowedPeers;
}

class PeerInfo {
  final String peerId;
  final String? hostname;
  final String os;
  final String? publicIp;
  final List<String> privateIps;
  final BigInt createdAt;
  final BigInt lastConnected;
  final String version;

  const PeerInfo({
    required this.peerId,
    this.hostname,
    required this.os,
    this.publicIp,
    required this.privateIps,
    required this.createdAt,
    required this.lastConnected,
    required this.version,
  });

  @override
  int get hashCode =>
      peerId.hashCode ^
      hostname.hashCode ^
      os.hashCode ^
      publicIp.hashCode ^
      privateIps.hashCode ^
      createdAt.hashCode ^
      lastConnected.hashCode ^
      version.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PeerInfo &&
          runtimeType == other.runtimeType &&
          peerId == other.peerId &&
          hostname == other.hostname &&
          os == other.os &&
          publicIp == other.publicIp &&
          privateIps == other.privateIps &&
          createdAt == other.createdAt &&
          lastConnected == other.lastConnected &&
          version == other.version;
}

class PeerWithInfo {
  final String peerId;
  final PeerInfo? peerInfo;

  const PeerWithInfo({required this.peerId, this.peerInfo});

  @override
  int get hashCode => peerId.hashCode ^ peerInfo.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PeerWithInfo &&
          runtimeType == other.runtimeType &&
          peerId == other.peerId &&
          peerInfo == other.peerInfo;
}

class TcpTunnelingConfig {
  final bool forwardingEnabled;
  final bool listeningEnabled;
  final List<ForwardingRule> forwardingRules;
  final List<ListeningRule> listeningRules;

  const TcpTunnelingConfig({
    required this.forwardingEnabled,
    required this.listeningEnabled,
    required this.forwardingRules,
    required this.listeningRules,
  });

  @override
  int get hashCode =>
      forwardingEnabled.hashCode ^
      listeningEnabled.hashCode ^
      forwardingRules.hashCode ^
      listeningRules.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is TcpTunnelingConfig &&
          runtimeType == other.runtimeType &&
          forwardingEnabled == other.forwardingEnabled &&
          listeningEnabled == other.listeningEnabled &&
          forwardingRules == other.forwardingRules &&
          listeningRules == other.listeningRules;
}

class WebdavProxy {
  final bool enabled;
  final String host;
  final int port;

  const WebdavProxy({
    required this.enabled,
    required this.host,
    required this.port,
  });

  @override
  int get hashCode => enabled.hashCode ^ host.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebdavProxy &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          host == other.host &&
          port == other.port;
}
