// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `parse_peer_id`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `from`

Future<void> startFungiDaemon() =>
    RustLib.instance.api.crateApiFungiStartFungiDaemon();

String? hostName() => RustLib.instance.api.crateApiFungiHostName();

String peerId() => RustLib.instance.api.crateApiFungiPeerId();

String configFilePath() => RustLib.instance.api.crateApiFungiConfigFilePath();

List<String> getIncomingAllowedPeersList() =>
    RustLib.instance.api.crateApiFungiGetIncomingAllowedPeersList();

void addIncomingAllowedPeer({required String peerId}) =>
    RustLib.instance.api.crateApiFungiAddIncomingAllowedPeer(peerId: peerId);

void removeIncomingAllowedPeer({required String peerId}) =>
    RustLib.instance.api.crateApiFungiRemoveIncomingAllowedPeer(peerId: peerId);

bool getFileTransferServiceEnabled() =>
    RustLib.instance.api.crateApiFungiGetFileTransferServiceEnabled();

String getFileTransferServiceRootDir() =>
    RustLib.instance.api.crateApiFungiGetFileTransferServiceRootDir();

Future<void> startFileTransferService({required String rootDir}) => RustLib
    .instance
    .api
    .crateApiFungiStartFileTransferService(rootDir: rootDir);

void stopFileTransferService() =>
    RustLib.instance.api.crateApiFungiStopFileTransferService();

Future<void> addFileTransferClient({
  required bool enabled,
  String? name,
  required String peerId,
}) => RustLib.instance.api.crateApiFungiAddFileTransferClient(
  enabled: enabled,
  name: name,
  peerId: peerId,
);

void removeFileTransferClient({required String peerId}) =>
    RustLib.instance.api.crateApiFungiRemoveFileTransferClient(peerId: peerId);

Future<void> enableFileTransferClient({
  required String peerId,
  required bool enabled,
}) => RustLib.instance.api.crateApiFungiEnableFileTransferClient(
  peerId: peerId,
  enabled: enabled,
);

List<FileTransferClient> getAllFileTransferClients() =>
    RustLib.instance.api.crateApiFungiGetAllFileTransferClients();

FtpProxy getFtpProxy() => RustLib.instance.api.crateApiFungiGetFtpProxy();

void updateFtpProxy({
  required bool enabled,
  required String host,
  required int port,
}) => RustLib.instance.api.crateApiFungiUpdateFtpProxy(
  enabled: enabled,
  host: host,
  port: port,
);

WebdavProxy getWebdavProxy() =>
    RustLib.instance.api.crateApiFungiGetWebdavProxy();

void updateWebdavProxy({
  required bool enabled,
  required String host,
  required int port,
}) => RustLib.instance.api.crateApiFungiUpdateWebdavProxy(
  enabled: enabled,
  host: host,
  port: port,
);

class FileTransferClient {
  final bool enabled;
  final String? name;
  final String peerId;

  const FileTransferClient({
    required this.enabled,
    this.name,
    required this.peerId,
  });

  @override
  int get hashCode => enabled.hashCode ^ name.hashCode ^ peerId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FileTransferClient &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          name == other.name &&
          peerId == other.peerId;
}

class FtpProxy {
  final bool enabled;
  final String host;
  final int port;

  const FtpProxy({
    required this.enabled,
    required this.host,
    required this.port,
  });

  @override
  int get hashCode => enabled.hashCode ^ host.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FtpProxy &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          host == other.host &&
          port == other.port;
}

class WebdavProxy {
  final bool enabled;
  final String host;
  final int port;

  const WebdavProxy({
    required this.enabled,
    required this.host,
    required this.port,
  });

  @override
  int get hashCode => enabled.hashCode ^ host.hashCode ^ port.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is WebdavProxy &&
          runtimeType == other.runtimeType &&
          enabled == other.enabled &&
          host == other.host &&
          port == other.port;
}
